#!/usr/bin/env ruby

#!/usr/bin/env ruby
require 'gli'
require 'fission-packaging/version'

FISSION_GEM_SOURCE = 'https://fission-gems.hw-ops.com'

include GLI::App

program_desc 'Generate a fission package'

version Fission::Packaging::VERSION.version

desc 'Remove all generated files'
command :clean do |c|
  require 'fileutils'
  c.action do |global_options, options, args|
    puts 'Cleaning... '
    %w(package src).each do |dir|
      print "  * removing directory #{dir} ... "
      FileUtils.rm_rf(dir)
      puts 'done'
    end
    print "  * removing build_configuration.rb ... "
    FileUtils.rm('build_configuration.rb')
    puts 'done'
    puts 'Cleaning complete!'
  end
end

arg_name 'PRODUCT', :required
command :build do |c|
  c.desc 'Use custom gem source for fission gems'
  c.flag :source

  c.action do |global_options, options, args|
    unless(RUBY_PLATFORM == 'java')
      puts 'ERROR: Use jruby for build!'
      exit -1
    end
    product = args.first
    puts "Building #{product}..."
    if(product == 'fission')
      puts 'This should build all the things'
      raise 'not done yet'
    else
      print '  * initial src/ population... '
      FileUtils.mkdir_p('src')
      File.open('src/Gemfile', 'w') do |file|
        file.puts "source 'https://rubygems.org'"
        file.puts "source '#{options[:source] || FISSION_GEM_SOURCE}'"
        file.puts "gem '#{product}'"
      end
      puts 'complete'
      print '  * vendoring gems... '
      Dir.chdir('src') do
        unless(system('bundle install 2>&1 > /dev/null'))
          puts 'FAILED'
          exit -1
        end
      end
      puts 'done'
      print '  * compacting vendored gems... '
      Dir.chdir('src') do
        %x{lib/jruby/1.9/bundler/gems/* lib/jruby/1.9/gems/}
        %w(bin bundler cache doc specifications).each do |leaf|
          FileUtils.rm_rf(
            File.join('lib/jruby/1.9', leaf)
          )
        end
      end
      puts 'done'
      print '  * compiling ruby files to java class files... '
      Dir.chdir('src') do
        unless(system('jrubyc lib/'))
          puts 'FAILED'
          exit -1
        end
      end
      puts 'done'
      print '  * removing any cruft files... '
      Dir.glob('src/lib/**/*').each do |path|
        next if path.end_with?('.class')
        FileUtils.rm(path)
      end
      puts 'done'
      class_files = Dir.glob('src/lib/**/*.class')
      print '  * writing main.rb file... '
      Dir.chdir('src') do
        libs = Dir.glob('lib/jruby/1.9/gems/*').map do |path|
          File.join('src', path, 'lib')
        end
        File.open('main.rb', 'w') do |file|
          file.puts "#{libs.inspect}.each{|path| $LOAD_PATH.unshift(path)}"
          file.puts "require 'fission'"
        end
      end
      puts 'done'
      print '  * writing build_configuration.rb ... '
      content = [
        "configuration{|c|",
        "c.project_name = '#{product.split('-').slice(1, 10).join('-')}'",
        "c.output_dir = 'package'",
        "c.executable_type = 'console'",
        "c.main_ruby_file = 'main'",
        "c.source_dirs = ['src']",
        "c.files_to_copy = #{class_files.inspect}",
        "c.source_jvm_version = #{ENV_JAVA['java.specification.version']}",
        "c.target_jvm_version = #{ENV_JAVA['java.specification.version']}",
        "}"
      ]
      File.open('build_configuration.rb', 'w') do |file|
        file.puts content.join("\n")
      end
      puts 'done'
      print '  * STAND BACK! BUILDING JAR... '
      unless(system('rake rawr:jar 2>&1 > /dev/null'))
        puts 'FAILED! BOOOOO'
        exit -1
      end
      puts 'done!'
      puts 'Packaging complete. Check out the package directory for jar!'
    end
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
