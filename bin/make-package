#!/usr/bin/env ruby
require 'gli'
require 'fission-packaging/version'

# Bug fix patching
class Gem::Version
  def self.create input
    if self === input then # check yourself before you wreck
      # yourself
      input
    elsif input.nil? then
      nil
    else
      new input
    end
  end
end

FISSION_GEM_SOURCE = nil #'https://fission-gems.hw-ops.com'
FISSION_SRC_DIR = 'src'

def action(doing)
  print "#{doing}... "
  yield
  puts 'done'
end

include GLI::App

program_desc 'Generate a fission package'

version Fission::Packaging::VERSION.version

desc 'Build PRODUCT'
arg_name 'PRODUCT', :required
command :build do |c|
  c.flag :source, :desc => 'Use custom gem source for fission gems'
  c.switch :verbose, :desc => 'Be noisy'
  c.flag :gemfile, :desc => 'Use provided Gemfile'
  c.flag :carnivore, :desc => 'Include carnivore sources', :type => Array
  c.switch :cleanup, :desc => 'Automatically clean up', :default_value => true

  c.action do |global_options, options, args|
    require 'fileutils'
    require 'warbler'

    product = args.first

    if(options[:cleanup])
      FileUtils.rm_rf(FISSION_SRC_DIR)
    end
    unless(File.directory?(File.join(FISSION_SRC_DIR, 'config')))
      FileUtils.mkdir_p(File.join(FISSION_SRC_DIR, 'config'))
      FileUtils.mkdir_p(File.join(FISSION_SRC_DIR, 'bin'))
    end
    action 'Generating gemfile' do
      if(options[:gemfile])
        gemfile = File.readlines(options[:gemfile])
      else
        gemfile = ["source 'https://rubygems.org'"]
      end
      gemfile.push("source '#{FISSION_GEM_SOURCE}'") if FISSION_GEM_SOURCE
      gemfile.push("source '#{options[:source]}'") if options[:source]
      if(options[:carnivore])
        options[:carnivore].each do |carnivore_src|
          unless(carnivore_src.start_with?('carnivore'))
            carnivore_src = "carnivore-#{carnivore_src}"
          end
          gemfile.push "gem '#{carnivore_src}'"
        end
      end
      File.open(File.join(FISSION_SRC_DIR, 'Gemfile'), 'w') do |file|
        file.puts gemfile.join("\n")
      end
    end
    action 'Generating package config file' do
      warble = ['Warbler.framework_detection = false', 'Warbler::Config.new do |c|']
      warble << 'c.features = []' #%w(compiled)'
      warble << "c.jar_name = \"#{product}-\#{Time.now.to_i}\""
      warble << 'c.bundler = true'
#      warble << 'c.compiled_ruby_files = FileList["vendor/**/fission*/**/*.rb"]'
      warble << 'end'
      File.open(File.join(FISSION_SRC_DIR, 'config', 'warble.rb'), 'w') do |file|
        file.puts warble.join("\n")
      end
    end
    action 'Installing executable' do
      binfile = [
        '#!/usr/bin/env ruby',
        'Dir.glob(File.expand_path("../../../gems/*", __FILE__)).each{|path| $:.unshift File.join(path, "lib")}',
        'Dir.glob(File.expand_path("../../../bundler/gems/*", __FILE__)).each{|path|  $:.unshift File.join(path, "lib")}',
        'require "fission"',
        'require "fission/runner"'
      ]
      File.open(File.join(FISSION_SRC_DIR, 'bin', product), 'w') do |file|
        file.puts binfile.join("\n")
      end
    end

    action 'Installing package bundle and build' do
      Dir.chdir(FISSION_SRC_DIR) do
        Bundler.with_clean_env do
          begin
            Bundler.ui.instance_eval do
              def quiet?
                true
              end
            end
            Bundler.clear_gemspec_cache
            Bundler.instance_variable_set(:@load, nil)
            Bundler.instance_variable_set(:@definition, nil)
            Bundler.instance_variable_set(:@setup, nil)
            Bundler.instance_variable_set(:@bundle_path, nil)
            Bundler.instance_variable_set(:@configured, nil)
            Bundler.send(:configure_gem_home_and_path)
#            Bundler.settings[:path] = 'vendor'
            Bundler.configure
            definition = Bundler.definition
            definition.validate_ruby!
            Bundler::Installer.install(FISSION_SRC_DIR, definition, {})
            Warbler::Task.new
            Rake::Task[:jar].invoke
          rescue => e
            puts "ACK: #{e}: #{e.backtrace.join("\n")}"
            exit
          end
        end
      end
    end

    jar = Dir.glob(File.join(FISSION_SRC_DIR, '*.jar')).first

    action 'Cleaning up' do
      FileUtils.mkdir_p('package')
      FileUtils.mv(jar, 'package')
      FileUtils.rm_rf(FISSION_SRC_DIR)
    end
    puts 'YAY! \o/'
    puts "Package build complete (#{product}): #{File.join('package', File.basename(jar))}"
  end
end

desc 'Remove all generated files'
command :clean do |c|
  require 'fileutils'
  c.action do |global_options, options, args|
    puts 'Cleaning... '
    %w(package src tmp).each do |path|
      print "  * removing #{path} ... "
      FileUtils.rm_rf(path)
      puts 'done'
    end
    puts 'Cleaning complete!'
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
