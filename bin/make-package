#!/usr/bin/env ruby
require 'gli'
require 'fission-packaging/version'

# Bug fix patching
class Gem::Version
  def self.create input
    if self === input then # check yourself before you wreck
      # yourself
      input
    elsif input.nil? then
      nil
    else
      new input
    end
  end
end

FISSION_GEM_SOURCE = nil #'https://fission-gems.hw-ops.com'
FISSION_SRC_DIR = 'src'
FISSION_PKG_DIR = 'package'

def action(doing)
  print "#{doing}... "
  yield
  puts 'done'
end

include GLI::App

program_desc 'Generate a fission package'

version Fission::Packaging::VERSION.version

desc 'Build PRODUCT'
arg_name 'PRODUCT', :required
command :build do |c|
  c.flag :source, :desc => 'Use custom gem source for fission gems'
  c.switch :verbose, :desc => 'Be noisy'
  c.switch :compile, :desc => 'Compile fission specific files', :default_value => true
  c.flag :gemfile, :desc => 'Use provided Gemfile'
  c.flag :carnivore, :desc => 'Include carnivore sources', :type => Array
  c.switch :cleanup, :desc => 'Automatically clean up', :default_value => true

  c.action do |global_options, options, args|
    require 'fileutils'
    require 'warbler'

    product = args.first

    if(options[:cleanup])
      [FISSION_SRC_DIR, FISSION_PKG_DIR].each do |dir|
        FileUtils.rm_rf(dir)
      end
    end
    unless(File.directory?(File.join(FISSION_SRC_DIR, 'config')))
      FileUtils.mkdir_p(File.join(FISSION_SRC_DIR, 'config'))
      FileUtils.mkdir_p(File.join(FISSION_SRC_DIR, 'bin'))
    end
    action 'Generating gemfile' do
      if(options[:gemfile])
        gemfile = File.readlines(options[:gemfile])
      else
        gemfile = ["source 'https://rubygems.org'"]
      end
      gemfile.push("source '#{FISSION_GEM_SOURCE}'") if FISSION_GEM_SOURCE
      gemfile.push("source '#{options[:source]}'") if options[:source]
      if(options[:carnivore])
        options[:carnivore].each do |carnivore_src|
          unless(carnivore_src.start_with?('carnivore'))
            carnivore_src = "carnivore-#{carnivore_src}"
          end
          gemfile.push "gem '#{carnivore_src}'"
        end
      end
      File.open(File.join(FISSION_SRC_DIR, 'Gemfile'), 'w') do |file|
        file.puts gemfile.join("\n")
      end
    end
    action 'Generating package config file' do
      warble = ['Warbler.framework_detection = false']
      warble << 'class ProxyProc < Proc; def method_missing(*args, &block); self.call.send(*args, &block); end; def respond_to?(m); call.send(:respond_to?, m); end; end'
      warble << 'Warbler::Config.new do |c|'
      # NOTE: File we need compiled can't be done here annoyingly enough
      warble << 'c.features = [] #%w(compiled)'
      warble << "c.jar_name = \"#{product}-\#{Time.now.to_i}\""
      warble << 'c.bundler = true'
#      warble << 'c.compiled_ruby_files = ProxyProc.new{ x = FileList["**/fission*/**/*.rb"]; puts x.inspect; x}'
      warble << 'end'
      File.open(File.join(FISSION_SRC_DIR, 'config', 'warble.rb'), 'w') do |file|
        file.puts warble.join("\n")
      end
    end
    action 'Installing executable' do
      binfile = [
        '#!/usr/bin/env ruby',
        'Dir.glob(File.expand_path("../../../gems/*", __FILE__)).each{|path| $:.unshift File.join(path, "lib")}',
        'Dir.glob(File.expand_path("../../../bundler/gems/*", __FILE__)).each{|path|  $:.unshift File.join(path, "lib")}',
        'require "fission"',
        'require "fission/runner"'
      ]
      File.open(File.join(FISSION_SRC_DIR, 'bin', product), 'w') do |file|
        file.puts binfile.join("\n")
      end
    end

    action 'Installing package bundle and build' do
      Dir.chdir(FISSION_SRC_DIR) do
        Bundler.with_clean_env do
          begin
            Bundler.ui.instance_eval do
              def quiet?
                true
              end
            end
            Bundler.clear_gemspec_cache
            Bundler.instance_variable_set(:@load, nil)
            Bundler.instance_variable_set(:@definition, nil)
            Bundler.instance_variable_set(:@setup, nil)
            Bundler.instance_variable_set(:@bundle_path, nil)
            Bundler.instance_variable_set(:@configured, nil)
            Bundler.send(:configure_gem_home_and_path)
#            Bundler.settings[:path] = 'vendor'
            Bundler.configure
            definition = Bundler.definition
            definition.validate_ruby!
            Bundler::Installer.install(FISSION_SRC_DIR, definition, {})
            Warbler::Task.new
            Rake::Task[:jar].invoke
          rescue => e
            puts "Unexpected exception encountered: #{e}: #{e.backtrace.join("\n")}"
            exit
          end
        end
      end
    end

    jar = Dir.glob(File.join(FISSION_SRC_DIR, '*.jar')).first

    action 'Cleaning up' do
      FileUtils.mkdir_p(FISSION_PKG_DIR)
      FileUtils.mv(jar, FISSION_PKG_DIR)
      FileUtils.rm_rf(FISSION_SRC_DIR)
    end

    jar = File.join(FISSION_PKG_DIR, File.basename(jar))

    if(options[:compile])
      action 'Compiling fission specific libraries' do
        raise 'Failed to unpack new jar!' unless system("unzip -q #{jar} -d #{FISSION_PKG_DIR}")
        FileUtils.rm jar
        fission_files = Dir.glob(File.join(FISSION_PKG_DIR, 'bundler/**/fission*/**/lib/**/*')).map(&:to_s)
        fission_files.delete_if{|f| !f.end_with?('.rb')}
        raise 'Fission specific java compilation failed!' unless system("jrubyc #{fission_files.join(' ')}")
        fission_files.each do |path|
          File.open(path, 'w'){|f| f.puts "load __FILE__.sub(/\.rb$/, '.class')"}
        end
        Dir.chdir(FISSION_PKG_DIR) do
          raise 'Failed to repack jar!' unless system("zip -q -r #{File.basename(jar)} .")
        end
=begin
        package_files = Hash[*(Dir.glob(File.join(FISSION_PKG_DIR, '**/**/*')).map{|i|[i,i.sub(FISSION_PKG_DIR, '')]}.flatten)]
        new_jar = Warbler::Jar.new
        new_jar.create_jar(jar, package_files)
=end
        Dir.glob(File.join(FISSION_PKG_DIR, "*")).each do |path|
          FileUtils.rm_rf(path) unless File.expand_path(path) == File.expand_path(jar)
        end
      end
    end

    puts 'YAY! \o/'
    puts "Package build complete (#{product}): #{File.join(FISSION_PKG_DIR, File.basename(jar))}"
  end
end

desc 'Remove all generated files'
command :clean do |c|
  require 'fileutils'
  c.action do |global_options, options, args|
    puts 'Cleaning... '
    %w(package src tmp).each do |path|
      print "  * removing #{path} ... "
      FileUtils.rm_rf(path)
      puts 'done'
    end
    puts 'Cleaning complete!'
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
