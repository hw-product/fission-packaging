#!/usr/bin/env ruby
require 'gli'
require 'fission-packaging/version'

FISSION_GEM_SOURCE = 'https://fission-gems.hw-ops.com'

include GLI::App

program_desc 'Generate a fission package'

version Fission::Packaging::VERSION.version

desc 'Fetch jruby-complete jar'
command :jrubyjar do |c|
  c.desc 'Set version to download'
  c.default_value '1.7.8'
  c.flag :version
  c.action do |g_o, options, args|
    uri = "http://jruby.org.s3.amazonaws.com/downloads/#{options[:version]}/jruby-complete-#{options[:version]}.jar"
    puts "Downloading jruby-complete.jar (version: #{options[:version]})!"
    FileUtils.mkdir_p('lib/java')
    exec("wget -O lib/java/jruby-complete.jar '#{uri}'")
  end
end

desc 'Remove all generated files'
command :clean do |c|
  require 'fileutils'
  c.action do |global_options, options, args|
    puts 'Cleaning... '
    %w(package src tmp).each do |path|
      print "  * removing #{path} ... "
      FileUtils.rm_rf(path)
      puts 'done'
    end
    puts 'Cleaning complete!'
  end
end

arg_name 'PRODUCT', :required
command :build do |c|
  c.desc 'Use custom gem source for fission gems'
  c.flag :source

  c.desc 'Be noisy'
  c.switch :verbose

  c.desc 'Use provided Gemfile'
  c.flag :gemfile

  c.desc 'Compile fission only'
  c.switch :fission
  c.action do |global_options, options, args|
    unless(RUBY_PLATFORM == 'java')
      puts 'ERROR: Use jruby for build!'
      exit -1
    end
    product = args.first
    unless(product)
      puts 'ERROR: Specify a product name'
      exit -1
    end
    puts "Building #{product}..."
    if(product == 'fission')
      puts 'This should build all the things'
      raise 'not done yet'
    else
      unless(File.exists?('lib/java/jruby-complete.jar'))
        puts 'ERROR: Fetch the jruby-complete.jar (jrubyjar command)'
        exit -1
      end
      print '  * initial src/ population... '
      FileUtils.mkdir_p('src')
      if(options[:gemfile])
        FileUtils.cp(options[:gemfile], 'src/Gemfile')
      else
        File.open('src/Gemfile', 'w') do |file|
          file.puts "source 'https://rubygems.org'"
          file.puts "source '#{options[:source] || FISSION_GEM_SOURCE}'"
          file.puts "gem '#{product}'"
        end
      end
      puts 'complete'
      print '  * vendoring gems... '
      %x{cp .bundle/config .bundle/config.bak} if File.exists?(".bundle/config")
      Bundler.with_clean_env do
        unless(system("bundle install --gemfile ./src/Gemfile --path ./lib #{'2>&1 > /dev/null' unless options[:verbose]}"))
          puts 'FAILED'
          exit -1
        end
      end
      %x{mv .bundle/config.bak .bundle/config} if File.exists?(".bundle/config.bak")
      puts 'done'
      print '  * compacting vendored gems... '
      Dir.glob('src/lib/jruby/1.9/bundler/gems/*').each do |path|
        next unless File.directory?(path)
        unless(system("mv #{path} src/lib/jruby/1.9/gems/"))
          puts 'FAILED'
          exit -1
        end
      end
      puts 'done'
      print '  * removing test and example files... '
      %w(test tests example examples).each do |key|
        Dir.glob("src/lib/**/#{key}/**/*.rb").each do |junk|
          File.delete(junk)
        end
      end
      puts 'done'
      print '  * compiling ruby files to java class files... '
      compile_path = options[:fission] ? 'src/lib/jruby/1.9/gems/fission*' : 'src/lib/jruby/1.9/gems'
      unless(system("jrubyc #{compile_path} #{'2>&1 > /dev/null' unless options[:verbose]}"))
        puts 'FAILED'
        exit -1
      end
      puts 'done'
      print '  * removing any cruft files... '
      Dir.glob('src/lib/jruby/1.9/gems/**/*').each do |path|
        if(options[:fission])
          next if !File.file?(path) ||
            path.end_with?('.class') ||
            (path.end_with?('.rb') && !File.exists?(path.sub('.rb', '.class')))
        else
          next if path.end_with?('.class') || !File.file?(path)
        end
        FileUtils.rm(path) if path.end_with?('.rb') || path.end_with?('.java')
      end
      puts 'done'
      FileUtils.mkdir_p('tmp')
      print '  * unpacking jruby-complete.jar file... '
      unless(system('unzip -q lib/java/jruby-complete.jar -d tmp/'))
        puts 'FAILED!'
        exit -1
      end
      puts 'done'
      print '  * import custom files... '
      FileUtils.mkdir_p('tmp/META-INF/jruby.home/fission')
      unless(system('mv src/lib/jruby/1.9/gems/* tmp/META-INF/jruby.home/fission/'))
        puts 'FAILED!'
        exit -1
      end
      puts 'done'
      print "  * packing up #{product} jar file... "
      FileUtils.mkdir_p('package')
      unless(system("cd tmp && zip -q ../package/#{product}-inprogress.jar -r * && cd .."))
        puts 'FAILED!'
        exit -1
      end
      puts 'done'
      print '  * resetting jar bootstrap... '
      paths = Dir.glob('tmp/META-INF/jruby.home/fission/*').map do |path|
        next unless File.directory?(path)
        File.join('fission', File.basename(path), 'lib')
      end.compact
      File.open('package/jar-bootstrap.rb', 'w') do |file|
        file.puts "base = $LOAD_PATH.detect{|x|x.include?('META-INF') && x.include?('jruby.home')}.scan(%r{^.*/jruby\.home}).flatten.first"
        file.puts "#{paths.inspect}.each{|path| $:.unshift File.join(base, path) }"
        file.puts 'require "fission"'
      end
      unless(system("cd package && jar ufe #{product}-inprogress.jar org.jruby.JarBootstrapMain jar-bootstrap.rb && cd .."))
        puts 'FAILED!'
        exit -1
      end
      FileUtils.rm_f("package/jar-bootstrap.rb")
      package_file_name = "package/#{product}-#{Time.now.to_i}.jar"
      system("mv package/#{product}-inprogress.jar #{package_file_name}")
      puts 'done'
      puts "Build of #{product} is complete! - #{package_file_name}"
      puts "Yay!"
    end
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
